## . A Simple Function (No Input)

This is the most basic formâ€”it just performs an action.



```Python
def say_hello():
    print("Hello! Welcome to Python.")

# Calling the function
say_hello()
```

---

## 2. Functions with Arguments (Input)

Arguments allow you to pass data into a function so it can be dynamic.



```Python
def greet_user(username):
    print(f"Welcome back, {username}!")

greet_user("Alice")
greet_user("Bob")
```

---

## 3. Functions with Return Values (Output)

Most of the time, you don't just want to print something; you want the function to calculate a value and give it back to you so you can use it later.



```Python
def calculate_area(width, height):
    area = width * height
    return area

# We store the result in a variable
my_room = calculate_area(10, 12)
print(f"The total area is: {my_room} sq ft")
```

---

## 4. Default Parameters

You can give arguments a "fallback" value in case the user forgets to provide one.



```Python
def power_up(name, level=1):
    print(f"{name} is now level {level}!")

power_up("Link", 5) # Uses 5
power_up("Zelda")   # Uses the default 1
```

---

## Summary Table

|Feature|Description|Example|
|---|---|---|
|**Parameter**|The variable listed in the function definition.|`def func(x):`|
|**Argument**|The actual value sent to the function when calling it.|`func(10)`|
|**Return**|Exits the function and sends a result back.|`return x * 2`|
|**Scope**|Variables created inside a function stay inside it.|Local vs Global|

Export to Sheets

---


# position arguments and key arguments in functions

## 1. Positional Arguments

These are the most common. The order in which you pass the values matters because Python assigns them to the function's parameters based on their **position**.

Python

```Python
def describe_pet(animal_type, pet_name):
    print(f"I have a {animal_type} named {pet_name}.")

# Correct order:
describe_pet("Hamster", "Harry")  
# Output: I have a Hamster named Harry.

# Wrong order:
describe_pet("Harry", "Hamster")  
# Output: I have a Harry named Hamster. (Doesn't make sense!)
```

- **Pros:** Quick to write.
    
- **Cons:** You have to remember the exact order of parameters.
    

---

## 2. Keyword Arguments

With keyword arguments, you explicitly state which parameter you are providing a value for using the name (`key=value`). The order no longer matters.



```Python
def describe_pet(animal_type, pet_name):
    print(f"I have a {animal_type} named {pet_name}.")

# The order doesn't matter here!
describe_pet(pet_name="Harry", animal_type="Hamster")
# Output: I have a Hamster named Harry.
```

- **Pros:** Much more readable and harder to mess up in long functions.
    
- **Cons:** Slightly more typing.

## 1. `*args` (Non-Keyword Arguments)

The `*` operator "packs" all the extra **positional** arguments you pass into a **tuple**.

This is perfect when you want a function to handle any number of inputs, like a sum calculator or a list joiner.


```Python
def add_everything(*numbers):
    # 'numbers' is now a tuple: (1, 2, 3, 4)
    total = sum(numbers)
    return total

print(add_everything(1, 2, 3, 4)) # Output: 10
print(add_everything(5, 10))       # Output: 15
```

---

## 2. `**kwargs` (Keyword Arguments)

The `**` operator "packs" all the extra **keyword** arguments (the `key=value` ones) into a **dictionary**.

This is incredibly useful for configuration settings, user profiles, or any situation where the data has labels.


```Python
def build_profile(first, last, **user_info):
    # 'user_info' is a dictionary
    profile = {'first_name': first, 'last_name': last}
    
    for key, value in user_info.items():
        profile[key] = value
        
    return profile

user = build_profile('Albert', 'Einstein', location='Princeton', field='Physics')
print(user)
# Output: {'first_name': 'Albert', 'last_name': 'Einstein', 'location': 'Princeton', 'field': 'Physics'}
```